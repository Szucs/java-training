<!DOCTYPE html>
<html>
<title>Unit 3: Debrief</title>
<link rel="stylesheet" type="text/css" href="base.css">
</style>
</head>
<body>
<a href="unit-3-fizz-buzz.html" title="previous">&lt;= Unit 3: Fizz Buzz</a> |<a href="index.html" title="home"> Top</a> |  <a href="unit-4-exploring-strings.html" title="next">Unit 4: Exploring Strings =&gt;</a>
<h1>Unit 3: Debrief</h1>
<p>
What did we learn in Unit 3? With respect to tools we learned:
</p>
<ul>
<li>An <em>integrated development environment</em> (IDE) bundles several useful development tools, presents them to you behind a unified user interface, and makes the tools aware of each other and of the code you are developing.</li>
<li>It's much more convenient to use an IDE than it is to use a plain text editor and command line tools.</li>
<li>A Java-aware editor helps with code completion and displays javadoc comments in context.</li>
<li>The IDE can perform compilation in the background while you work. You don't have to remember to run the compiler explicity.</li>
<li>An IDE can make it easier to deal with the classpath.</li>
<li>A dependency manager simplifies the problem of identifying and installing dependencies (in this case, Maven).</li>
<li>We learned the conventional directory structure for an Eclipse project to work smoothly with Maven.</li>
<li>We got started with using a unit testing framework called JUnit, which comes bundled with Eclipse.</li>
</ul>
<p>
With respect to development methods we learned:
</p>
<ul>
<li>Lightweight requirements artifacts provide enough information to get started with development without presenting so much detail that they are difficult to understand.</li>
<li>Lightweight requirements artifacts make significant assumptions about developer skills and self discipline, as they do not specify every detail about what must be done.</li>
<li>We learned the four key pieces of information that any requirements definition must contain in order to be useful to developers.</li>
<li>We learned the basic format for the most popular lightweight requirements artifact, the User Story.</li>
<li>We saw how the use of <em>personas</em> can help us understand user needs a little more clearly than basic user types.</li>
</ul>
<p>
With respect to software development practices we learned:
</p>
<ul>
<li>It's a good idea to break down any given functional scenario into very fine-grained pieces so that we can easily see where things go wrong.</li>
<li>Effective development often means switching between coding and testing activities frequently.</li>
<li>Incremental refactoring is relatively painless and less bothersome than waiting to address accumulated technical debt all at once.</li>
<li>A test-first development approach helps us see how to evolve our design and allows us to arrive at a clean design faster than we can usually do with a BDUF approach.</li>
<li>We saw how a test-first approach helps us know when to stop, so that we won't over-engineer solutions, and helps us verify and demonstrate that the acceptance criteria have been satisfied.</li>
</ul>
<p>
With respect to Java programming we learned:
</p>
<ul>
<li>How to use conditional statements.</li>
<li>How to use a few basic arithmetic operators.</li>
<li>How to define an array of values.</li>
<li>How to iterate over an array.</li>
</ul>

</body>
</html>